#!/usr/bin/perl
# this programme exports all debian source packages from svn and
# builds the debian packages, places then in the debian tree, builds the
# Packages file, updates apt-get.
use File::Basename;
use File::Find;
use Getopt::Std;

# remove working dir
sub removeworkingdir {
    # remove working dir
    chdir $workingdir;
    chdir "..";
    system("rm -rf *");
}

# given an archive name this function returns the package name or architecture
sub getpackagefield {
    $archive = $_[0];
    $field = $_[1];

    # get the package name from the control file
    @command = ("dpkg-deb -f", $archive, $_[1]);
    $field = `@command`;
    chomp $field;

    return $field;
}
# update override file appends the package name, optional and myown
# to override file. The file Packages is then created using dpkg-scanpackages
sub updateoverridefile {
    my($archive, $packagename);
    $archive = $_[0];

    #get package name
    $packagename = getpackagefield($archive, "Package");

    # write name Optional MyOwn to override file
    print OF $packagename, "\t\t\t\tOptional\tMyOwn\n";
}
# the give archive is added to the distribution tree
# all the correct directories are created if necesary
# the name is then added to the override file
# parameters passed: archive name, 'rename' to rename package to standard name
sub movearchivetotree {
    my($archive);

    # archive name in current directory where we are presently
    $archive = $_[0];
    
    # get package name
    $packagename = getpackagefield($archive, "Package");

    # make dir under pool/firstletter of packagename/packagename
    # get first character of string
    $firstchar = substr($packagename, 0, 1);

    # make directory
    $destination = $debianpool . "/" . $firstchar . "/" . $packagename;
    mkdir $debianpool . "/" . $firstchar;
    mkdir $destination;
    

    # append package name to override file
    # do this before the move because the package name is read from
    # the archive.
    updateoverridefile($archive);

    #copy debian package to pool/firstletterofname/name/file.deb
    system ("cp -v " . $archive . " " . $destination);

    if ($_[1] eq "rename") {
	# rename debian package to standard name
	$fullpathname = $destination . "/" . $archive;
	system("dpkg-name " . $fullpathname);
    }
}

# add_archives will move all archives in the given directory tree and
# placed in the Debian distribution tree.
# a directory must be passed to this function
sub add_archive {
    # get current selection if it is a file
    $archive = $File::Find::name;

    # print dir name
    
    # for each .deb file process it
    if( -f $archive) {
	# get the extension of the file name
	($file, $dir, $ext) = fileparse($archive, qr/\.[^.]*/);

	# move archive to debian dist tree and create dirs
	# if file is a i386 debian archive
	if ($ext eq ".deb") {
	    $architecture = getpackagefield($archive, "Architecture");
	    if ($architecture eq "i386" or $architecture eq "all") {
		movearchivetotree($archive, "norename");
	    }
	}
    }
}

# buildtree will recurse a directory and build all the source packages if
# necesary and pack them into a Debian distribution tree in the correct
# directories.
sub buildtree {
    # open a directory and list dirs inside
    opendir (DEB, $workingdir) or die "no dir: $!";
    chdir $workingdir;

    # descend into each subdirectory under the working dir DEB.
    foreach $name (readdir(DEB)) {
	if ($name ne ".." and $name ne "."){
	    print "Processing: ", $name, "\n";

	    chdir $name or die "cannot change to ",$name, ": $!";
	    
            # untar file if it exists
	    if (-e "contents.tar.gz") {
		system("tar -xpzf contents.tar.gz") ;

		# remove tar file
		unlink "contents.tar.gz";
	    }
	    # change back
	    chdir ".." or die "cannot go back";

	    # build debian package
	    system("dpkg -b " . $name);

	    # get name of package from control file
	    $archive = $name . ".deb";

	    # move archive to tree
	    movearchivetotree($archive, "rename");
	}
    }
    closedir(DEB);
    removeworkingdir();
}

# main entry point
# if no options print message
if (! $ARGV[0]) {
    print "usage: builddebiantree [options] filelist\
\t-n delete override file and make a new one.
\t-a extract all from subversion -> build all -> add to distribution tree\
\t-l list debian packages in repository\
\t-p extract package from subversion -> build -> add to distribution tree\
\t-s directory containing archives -> add to distribution tree\n";
    exit();
}
# default values
$debianroot = "/mnt/hdint/robert/debian/";
$debianpool = $debianroot . "pool";
$overridedir = $debianroot . "indices/";
$overridefile = $overridedir . "override";
$workingdir = "/mnt/hdint/robert/tmp/debian";
$packagesdir = $debianroot . "dists/etch/main/binary-i386";
$repository = "file:///mnt/hdint/svn/debian/";
$exportcommand = "svn --force -q export " . $repository;
$packagesfile = $packagesdir . "/" . "Packages";

#mkdir directories
system("mkdir -p " . $debianroot) if ! -d $debianroot;
system("mkdir -p " . $debianpool) if ! -d $debianpool;
system("mkdir -p " . $workingdir) if ! -d $workingdir;
system("mkdir -p " . $packagesdir) if ! -d $packagesdir;
system("mkdir -p " . $overridedir) if ! -d $overridedir;

# get command line options
getopts('alnp:s:');

# delete the override file if it exists
if ($opt_n) {
    unlink($overridefile) if -e;
    unlink($packagesfile) if -e;
}
    
# list all packages and exit
if ($opt_l) {
    $command = "svn -v list " . $repository;
    system($command);
}

# checkout all debian packages, build and place in tree
if ($opt_a) {
    # checkout debian packages
    $command = $exportcommand . " " . $workingdir;
    system($command);

    #open new override file for building of tree
    open OF, ">>". $overridefile or die "cannot open override file: $!\n";
    buildtree();
    close OF;
}

if ($opt_p) {
    # checkout only the one package

    $command = $exportcommand . $opt_p . " " . $workingdir . "/" . $opt_p;
    system($command);

    #open override file for appending
    open OF, ">>". $overridefile or die "cannot open override file: $!\n";
    buildtree();
    close OF;
}
# process a dir recursively and copy all debian i386 archives to tree
if ($opt_s) {
    # open override file for appending
    open OF, ">>". $overridefile or die "cannot open override file: $!\n";

    # recurse down dirs and move all archives to deb dist tree
    find \&add_archive, $opt_s;

    # close file
    close OF;
}
# only add packages to Packages file if -a or -s or -p was given
if ($opt_a or $opt_s or $opt_p) {
    #change to debian root
    chdir $debianroot;

    # make Packages file for debian distribution
    system("dpkg-scanpackages pool indices/override > dists/etch/main/binary-i386/Packages");
}
